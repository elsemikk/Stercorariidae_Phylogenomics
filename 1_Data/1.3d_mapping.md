# Mapping to the reference genome

After trimming reads, we can map them to the reference genome. I am generating two datasets mapping to two different reference genomes of different phylogenetic distances. First, we are mapping sequencing reads from each sample to the reference genome of *Stercorarius parasiticus*, which we assembled into pseudochromosomes based on synteny with *Alca torda*. This genome is part of our ingroup, and so should have better mapping quality, but some analyses would be biased because each sample will have a different genetic distance to the reference. I am calling this dataset "c". Next, I will map to the *Alca torda* genome, which is more distant, but is equally distant to each of the ingroup samples. I am calling that dataset dataset "d". Each of my filenames after these steps is labelled either "c" or "d" depending on which reference it is using.

### Overview
This section details how the trimmed sequencing reads were mapped to the *Alca torda* reference genome.

### Required Input
This step requires the trimmed sequencing read data, which was generated in the previous step (`1.1`), and a reference genome (from step `0.1`).

### Output
The output is sorted, indexed alignment data in bam format ready for genotype calling.

# Map with bowtie2

I am mapping the data using bowtie2 with the --very-sensitive setting, which should allow for mapping our slightly divergent (up to approximately 4.6% for the Alcid) genomes to the reference, without introducing too many mismappings. I tested several different settings with bowtie2 and with bwa, and selected bowtie2 --very-sensitive as it allowed for a higher mapping rate without elevating heterozygosity of the female Z chromosome (which should have no heterozygosity except for errors) - I found that the default settings with bwa allowed for a slightly higher mapping rate, but at the cost of elevating heterozygosity on the female Z, suggesting that mapping errors were being introduced.

Before we can map our sequences, we must prepare the reference genome for Bowtie2, if we have note done so already:  
```bash
cd /home/0_GENOMES1/0_RESEQUENCING_PROJECTS/2_PROJECTS/Stercorarius/0_Reference_genome/0.1_scaffolding/GCA_008658365.1/data/GCA_008658365.1/
#reference=/home/0_GENOMES5/Stercorarius/0_Reference_genome/0.1_scaffolding/GCA_008658365.1/data/GCA_008658365.1/GCA_008658365.1_bAlcTor1_genomic.fna
reference=/home/0_GENOMES1/0_RESEQUENCING_PROJECTS/2_PROJECTS/Stercorarius/0_Reference_genome/0.1_scaffolding/GCA_008658365.1/data/GCA_008658365.1/GCA_008658365.1_bAlcTor1_genomic.fna
reference_name=Alca_torda.ref

time /home/0_PROGRAMS/bowtie2-2.4.4-linux-x86_64/bowtie2-build "$reference" "$reference_name" #39m56.672s
time /home/0_PROGRAMS/samtools-1.14/samtools faidx "$reference" #0m4.733s
```
`Stercorarius_parasiticus.ref`: this is a tag name for the build, it will be the prefix of the output files and you will give this name to bowtie later when you do the mapping step.  

**Timing**:Building took 29m11.639s (1 thread) and indexing took only 4 seconds.

# Map to the indexed reference sequence

In this step, we will loop through our samples and map them to the reference genome using bowtie2. If you only have a single sequencing run per sample, then this is quite simple. However, most of our samples were divided across multiple sequencing runs. Now, we could simply concatenate the raw sequencing data from all runs of a given sample and map it in one go. However, doing so would erase some valuable information pertaining to the origin of each read. The reason that this matters is that during a sequencing run, a single DNA fragment is amplified many times to form clusters which are then read by the machine's sensors. If the machine misinterprets a single cluster as two adjacent clusters, it will produce "optical duplicates" - that is, two different reads that are identical because they originated from the exact same fragment of DNA. Since these do not represent independant replicates drawn from the genome, they can bias SNP calling pipelines that assume each sequenced read at diploid locus is a random draw from either homologous chromosome. Luckily, if we know that two reads came from adjacent clusters of the same sequencing flow cell, the optical duplicates can be identified and removed to keep only one copy.

For this to work, we need to supply some information to the mapper so that it known what sequencing run each read came from and can add this info into the .bam file. I am storing this info into a file that I will loop through to supply the necessary information to bowtie2 for each sample.  

This file has 6 tab-seperated columns.  
1) Sample name  
2) Unique ID for each run (I am naming with the convention `flowcell.lane.sample`)  
3) Library number (arbitrary, refers to samples that were prepped together in the lab)  
4) `Flowcell.lane.barcode`  
5) Platform (Illumina)  
6) Prefix used to identify the correct fastq files and name the output  

Some of this info may be in the .fastq file header. For example, we can read the first header line of our fastq files like this:
```bash
ls *_R1*.fastq.gz | while read file ; do echo $file ; zcat $file | head -n 1 ; done #for fastq.gz
ls *_R1*.fastq | while read file ; do echo $file ; head -n 1 $file ; done #for fastq

```
For example, for one of my samples the header looks like this:
```
@E00387:393:H7723CCX2:8:1101:25317:1116 2:N:0:46
```
This tells us that the read came from flowcell H7723CCX2 lane 8. I went through and collected this info from each file, where possible. Some of this info may be lacking in public data, such as from Genbank, to save file space.  

I saved this info into a text file that I can loop through:  

```bash
#First, make some folders to place our mappings
#mkdir -p /home/0_GENOMES5/Stercorarius/1_Data/1.3a_mapping #on Troglodytes, parasiticus reference
#cd /home/0_GENOMES5/Stercorarius/1_Data/1.3a_mapping
mkdir -p /home/0_GENOMES1/0_RESEQUENCING_PROJECTS/2_PROJECTS/Stercorarius/1_Data/1.3d_mapping #on main server, Alca reference
cd /home/0_GENOMES1/0_RESEQUENCING_PROJECTS/2_PROJECTS/Stercorarius/1_Data/1.3d_mapping

#paste the readgroups file
cat > readgroups
```
Here are the contents. The columns must be space-separated:  
```
CISK_3 H7VVVCCX2.1.CISK_32 Lib-3 H7VVVCCX2.1.NTCCTCCT ILLUMINA CISK3_S1_L001 
ANSK7 H7723CCX2.8.ANSK7 Lib-2 H7723CCX2.8.46 ILLUMINA ANSK7_S46_L008
GRSK_MKP1592 HWNWMCCXY.1.GRSK_MKP1592 Lib-1 HWNWMCCXY.1.NACTGAGC+NAATCAGG ILLUMINA HI.4998.001.IDT_i7_18---IDT_i5_18.GRSK_MKP1592
GRSK_MKP1592 HYFKVCCXY.1.GRSK_MKP1592 Lib-1 HYFKVCCXY.1.NACTGAGC+NAATCAGG ILLUMINA HI.5011.004.IDT_i7_18---IDT_i5_18.GRSK_MKP1592
CHSK_MKP2451 H2HVJCCX2.3.CHSK_MKP2451 Lib-1 H2HVJCCX2.3.NGCATGAT+NAGCCTGA ILLUMINA HI.5080.003.IDT_i7_7---IDT_i5_7.CHSK_MKP2451
CHSK_MKP2451 H2HVJCCX2.4.CHSK_MKP2451 Lib-1 H2HVJCCX2.4.NGCATGAT+NAGCCTGA ILLUMINA HI.5080.004.IDT_i7_7---IDT_i5_7.CHSK_MKP2451
POJA_MKP1559 HWNWMCCXY.1.POJA_MKP1559 Lib-1 HWNWMCCXY.1.NCGTCATT+NAGACGTT ILLUMINA HI.4998.001.IDT_i7_30---IDT_i5_30.POJA_MKP1559
POJA_MKP1559 HYFKVCCXY.4.POJA_MKP1559 Lib-1 HYFKVCCXY.4.NCGTCATT+NAGACGTT ILLUMINA HI.5011.004.IDT_i7_30---IDT_i5_30.POJA_MKP1559
LTJA_MKP990 HWNWMCCXY.1.LTJA_MKP990 Lib-1 HWNWMCCXY.1.NTGTTGAC+NCCTCAGT ILLUMINA HI.4998.001.IDT_i7_54---IDT_i5_54.LTJA_MKP990
LTJA_MKP990 HYFKVCCXY.4.LTJA_MKP990 Lib-1 HYFKVCCXY.4.NTGTTGAC+NCCTCAGT ILLUMINA HI.5011.004.IDT_i7_54---IDT_i5_54.LTJA_MKP990
PAJA_B20730 HYFKVCCXY.4.PAJA_B20730 Lib-1 HYFKVCCXY.4.NGGTTGTT+NTGGTATG ILLUMINA HI.5011.004.IDT_i7_42---IDT_i5_42.PAJA_B20730
PAJA_B20730 HWNWMCCXY.1.PAJA_B20730 Lib-1 HWNWMCCXY.1.NGGTTGTT+NTGGTATG ILLUMINA HI.4998.001.IDT_i7_42---IDT_i5_42.PAJA_B20730
ANSK01 HWWLTDSX2.1.ANSK01 Lib-4 HWWLTDSX2.1.TAATGCGC+AGGCTATA Illumina ANSK01_S7_L001
ANSK8 HWWLTDSX2.1.ANSK8 Lib-4 HWWLTDSX2.1.ATTCAGAA+GCCTCTAT Illumina ANSK8_S8_L001
CISK2 HWWLTDSX2.1.CISK2 Lib-4 HWWLTDSX2.1.CTGAAGCT+AGGCTATA Illumina CISK2_S6_L001
CISK55 HWWLTDSX2.1.CISK55 Lib-4 HWWLTDSX2.1.GAATTCGT+AGGCTATA Illumina CISK55_S5_L001
GRSK_MKP1593 HWWLTDSX2.1.GRSK_MKP1593 Lib-4 HWWLTDSX2.1.ATTCAGAA+AGGCTATA Illumina GRSK_MKP1593_S4_L001
POJA_4 HWWLTDSX2.1.POJA_4 Lib-4 HWWLTDSX2.1.CTGAAGCT+GCCTCTAT Illumina POJA_4_S10_L001
POJA_IB2659 HWWLTDSX2.1.POJA_IB2659 Lib-4 HWWLTDSX2.1.GAATTCGT+GCCTCTAT Illumina POJA_IB2659_S9_L001
PAJA_USNM606730 FCC2J5BACXX.2.PAJA_USNM606730 Lib-5 FCC2J5BACXX.2.NA ILLUMINA SRR10019945
PAJA_USNM606730 FCC2J5BACXX.1.PAJA_USNM606730 Lib-5 FCC2J5BACXX.1.NA ILLUMINA SRR10019934
Fratercula_arctica NA.NA.Fratercula_arctica Lib-5 NA.NA.NA ILLUMINA ERR4669697
Alca_torda FCC4UDBACXX.1.Alca_torda Lib-5 FCC4UDBACXX.1.NA ILLUMINA SRR9853758
Alca_torda FCC4UDBACXX.8.Alca_torda Lib-5 FCC4UDBACXX.8.NA ILLUMINA SRR9853828
Alca_torda FCC4UDBACXX.5.Alca_torda Lib-5 FCC4UDBACXX.5.NA ILLUMINA SRR9853829
Alca_torda FCC4UDBACXX.2.Alca_torda Lib-5 FCC4UDBACXX.2.NA ILLUMINA SRR9853830
Alca_torda FCC4UDBACXX.7.Alca_torda Lib-5 FCC4UDBACXX.7.NA ILLUMINA SRR9853831
Uria_lomvia C2F25ACXX.NA.Uria_lomvia Lib-5 C2F25ACXX.4.NA ILLUMINA SRR5884877
Uria_lomvia NA.NA.Uria_lomvia Lib-5 NA.NA.NA ILLUMINA SRR5884878
Uria_lomvia NA.NA.Uria_lomvia Lib-5 NA.NA.NA ILLUMINA SRR5884875

```

In addition, we will need a list of samples to loop through. This file will be very useful later on to cycle through the samples when you need to run the same commands on all samples, without needing to write out the same command 6 (or more) times. It is similar to the above file, but only lists the sample names, not the sequencing file names.  

```bash
cat > samples.txt #copy-paste the text below, press enter, and press ctrl-d to exit. Whatever you copy-pasted will be written to the file.
```
```
LTJA_MKP990
PAJA_B20730
POJA_MKP1559
CHSK_MKP2451
GRSK_MKP1592
ANSK01
ANSK8
CISK2
CISK55
GRSK_MKP1593
POJA_4
POJA_IB2659
CISK3
Fratercula_arctica
Alca_torda
PAJA_USNM606730
ANSK7
Uria_lomvia

```

Note: we need a final "return" at the end of the last line (creating a new blank line at the end) otherwise it will skip the last sample as it will lack a "newline" character at the end of the line - so just press "enter" once after you have copy-pasted it into terminal to start a new line before finishing your file. Also make sure there are no spaces or tabs at the end of the lines.  

## Map all samples to the reference
In a preliminary run of this project, I tested various settings of Bowtie2; these can be found in Appendix A below. I chose the `--very-sensitive` setting and also reduced the mismatch penalty (`--mp 5,1`) since I am mapping samples that are phylogenetically somewhat distant to the reference genome, and so we expect there to be many mismatches between the reference and the sequencing reads.    
We will feed the input `readgroups` file to `parallel` which will then parse the columns and place the required info to the bwa command which will run each sample in parallel. (tutorial on using parallel [here](https://opensource.com/article/18/5/gnu-parallel))  

We will pipe the output of bowtie2 directly into samtools sort and then fixmate, and then pipe the output of fixmate directly into samtools sort again, since we have no use for the unsorted, giant intermediate files. (there is a nice samtools tutorial [here](http://quinlanlab.org/tutorials/samtools/samtools.html))  

Once each sequencing run has been mapped, we can merge the runs of the same samples so that we only have one bam file per sample. we will directly pipe this merged file into samtools markdup to identify and mark the optical duplicates. Finally, we simply index the bam file and it is ready for downstream use! Note that we always convert the sam file to bam file format since sam files take up much more space (for example, a 63 Gb sam file can be stored as a 14-18 Gb bam file!)  

```bash
#set up environment
#cd /home/0_GENOMES5/Stercorarius/1_Data/1.3d_mapping #on node
cd /home/0_GENOMES1/0_RESEQUENCING_PROJECTS/2_PROJECTS/Stercorarius/1_Data/1.3d_mapping
cd /home/1_Else/0_GENOMES5/Stercorarius/1_Data/1.3d_mapping #on new server (SRA samples)

mkdir -p mapping_logs

#get readgroups file (see above)

#run the mapper and pipe output to fixmate
#Fixmate adds information on insert size and mate pair coordinates. note fixmate normally requires bam file to be sorted by read name, but bwa outputs the sam file essentially sorted by name already with mates one after the other. 
#before we can merge our sequencing runs, we must also sort each run by genomic position. 
reference=/home/0_GENOMES1/0_RESEQUENCING_PROJECTS/2_PROJECTS/Stercorarius/0_Reference_genome/0.1_scaffolding/GCA_008658365.1/data/GCA_008658365.1/Alca_torda.ref #on main server
reference=/home/1_Else/0_GENOMES5/Stercorarius/0_Reference_genome/0.1_scaffolding/GCA_008658365.1/data/GCA_008658365.1/Alca_torda.ref #on new server
tagname=RAZObowtie

#on new server (SRA samples)
cat readgroups | parallel --jobs 18 --colsep ' ' 'time /home/0_PROGRAMS/bowtie2-2.4.4-linux-x86_64/bowtie2 --end-to-end --very-sensitive --no-unal --threads 30 -q --phred33 --time --mp 5,1 -x '$reference' -1 ../1.1c_read_trimming/fltrd_adptrlss{6}_R1.fastq.gz -2 ../1.1c_read_trimming/fltrd_adptrlss{6}_R2.fastq.gz --rg-id {2} --rg SM:{1} --rg LB:{3} --rg PU:{4} --rg PL:{5} 2> mapping_logs/{6}.'$tagname'.log | /home/0_PROGRAMS/samtools-1.14/samtools sort -n -O sam | time /home/0_PROGRAMS/samtools-1.14/samtools fixmate -@ 2 -m - - | /home/0_PROGRAMS/samtools-1.14/samtools sort -O BAM > {6}.{1}_sorted.bam'

#on main server (new samples)
cat readgroups | parallel --jobs 18 --colsep ' ' 'time /home/0_PROGRAMS/bowtie2-2.4.4-linux-x86_64/bowtie2 --end-to-end --very-sensitive --no-unal --threads 1 -q --phred33 --time --mp 5,1 -x '$reference' -1 /home/0_GENOMES1/0_RESEQUENCING_PROJECTS/1_PROCESSED_READS/3_TRIMMED/Stercorariidae/1.1c_read_trimming/fltrd_adptrlss{6}_R1.fastq.gz -2 /home/0_GENOMES1/0_RESEQUENCING_PROJECTS/1_PROCESSED_READS/3_TRIMMED/Stercorariidae/1.1c_read_trimming/fltrd_adptrlss{6}_R2.fastq.gz --rg-id {2} --rg SM:{1} --rg LB:{3} --rg PU:{4} --rg PL:{5} 2> mapping_logs/{6}.'$tagname'.log | /home/0_PROGRAMS/samtools-1.14/samtools sort -n -O sam | time /home/0_PROGRAMS/samtools-1.14/samtools fixmate -@ 1 -m - - | /home/0_PROGRAMS/samtools-1.14/samtools sort -O BAM > {6}_sorted.bam'

#Now we can merge the results of each sequencing run for each sample (do not merge different samples together though! Each bam should be seperated into seperate files per SAMPLE, but we are merging different RUNS of the SAME sample). This is done based on naming each run with the name of the sample.
#right after merging, we can mark duplicates. We don't need any intermediate file for anything, so jut pipe directly to markdup.
mkdir -p merged
cat samples.txt | parallel 'time /home/0_PROGRAMS/samtools-1.14/samtools merge - *{1}*_sorted.bam -u | time /home/0_PROGRAMS/samtools-1.14/samtools markdup - merged/{1}.'$tagname'.marked.bam ; echo {1}' #took 145m5.032s (166m54.708s) for the largest (Uria)
#time /home/0_PROGRAMS/samtools-1.14/samtools merge - *SRR9853*_sorted.bam -u | time /home/0_PROGRAMS/samtools-1.14/samtools markdup -@ 4 - merged/Alca_torda."$tagname".marked.bam
#time /home/0_PROGRAMS/samtools-1.14/samtools merge - *SRR100*_sorted.bam -u | time /home/0_PROGRAMS/samtools-1.14/samtools markdup -@ 4 - merged/PAJA_USNM606730."$tagname".marked.bam
#time /home/0_PROGRAMS/samtools-1.14/samtools merge - *SRR100*_sorted.bam -u | time /home/0_PROGRAMS/samtools-1.14/samtools markdup -@ 4 - merged/PAJA_USNM606730."$tagname".marked.bam

#note that we MARKED duplicates but we did not remove them - they are still there. You can remove them with the -r flag.

#index the bam with samtools for downstream programs that require an index
cat samples.txt | parallel 'time /home/0_PROGRAMS/samtools-1.14/samtools index merged/{1}.'$tagname'.marked.bam'

#Now we have a bam file ready to use! BE AWARE: there has been no filtering. You will have to implement some filtering before calling genotypes etc.

#To save space, go ahead and delete any of the unmerged bam files. I see no reason you would need them for anything you could not used the merged files for, assuming the merging all went smoothly. Worst case scenario, you can remake them.
#rm ./*_sorted.bam #careful
```
bowtie2 settings:
* -`-rg-id`: Set the read group ID to <text>. This causes the SAM @RG header line to be printed, with <text> as the value associated with the ID: tag. It also causes the RG:Z: extra field to be attached to each SAM output record, with value set to <text>.
* `--rg` Add <text> (usually of the form TAG:VAL, e.g. SM:Pool1) as a field on the @RG header line. Note: in order for the @RG line to appear, --rg-id must also be specified. This is because the ID tag is required by the SAM Spec. Specify --rg multiple times to set multiple fields. See the SAM Spec for details about what fields are legal.
* `--no-unal`: Suppress SAM records for reads that failed to align.
* `--mp MX,MN` Sets the maximum (MX) and minimum (MN) mismatch penalties, both integers. A number less than or equal to MX and greater than or equal to MN is subtracted from the alignment score for each position where a read character aligns to a reference character, the characters do not match, and neither is an N. If --ignore-quals is specified, the number subtracted quals MX. Otherwise, the number subtracted is MN + floor( (MX-MN)(MIN(Q, 40.0)/40.0) ) where Q is the Phred quality value. Default: MX = 6, MN = 2.
samtools view:
* `-S`: the input is a SAM file (no longer required as this can be automatically detected)
* `-b`: the output will be BAM format
* `-@`: number of threads to use for BAM compression
* `-h`: include the header in the output
* `-q 5`: Skip alignments with MAPQ smaller than the specified number. This is to avoid multimapped sequences and mappings with low confidence. You could filter by 0 or 1, or 5 or 10, there is a discussion [here](https://www.biostars.org/p/101533/).
* `-f2`: only include properly paired reads
fixmate
* `-m`: "Add ms (mate score) tags. These are used by markdup to select the best reads to keep."
* -@: number of threads to use for BAM compression
samtools merge
* First list the output ("-" for piping), then the inputs
* `-u`: uncompressed output. Since we are just piping to the next command, no point wasting time compressing in between.
samtools markdup
* opposite of merge: first list the input, then the output

**Timing**: first batch of Stercorariids took 334m (888m) to 516m (1343m) depending on file size, using 4 threads each. Mapping to Alca took up to 1609m38.749s!

Now we have a bam file for each sample ready to call SNPs or use as input for analysis!

# Evaluate results

Now that we have mapped our samples, we can do some visualization and calculate some statistics to evaluate the mapping results.

First, I will get some general stats from samtools (manual for these commands [here](http://www.htslib.org/doc/samtools-1.6.html)).  
Then I will look at some more details with [Qualimap](http://qualimap.bioinfo.cipf.es/doc_html/analysis.html).  

Note, you don't have to run all of these QC programs, they are redundant, but I find it fun to compare.

I am running all my samples in parallel at the same time which is described [here](https://www.gettinggeneticsdone.com/2014/03/visualize-coverage-exome-targeted-ngs-bedtools.html)  
(I am NOT running Qualimap in parallel because that would take too much memory and crash. One at a time.)  

```bash
cd /home/0_GENOMES1/0_RESEQUENCING_PROJECTS/2_PROJECTS/Stercorarius/1_Data/1.3d_mapping #on main server
tagname=RAZObowtie

mkdir -p QC_reports

cat samples.txt | parallel 'time /home/0_PROGRAMS/samtools-1.14/samtools idxstats merged/{1}.'$tagname'.marked.bam > QC_reports/idxstats_{1}.txt'
cat samples.txt | parallel 'time /home/0_PROGRAMS/samtools-1.14/samtools flagstat merged/{1}.'$tagname'.marked.bam > QC_reports/flagstats_{1}.txt'
cat samples.txt | parallel 'time /home/0_PROGRAMS/samtools-1.14/samtools stats merged/{1}.'$tagname'.marked.bam > QC_reports/samstats_{1}.txt'

#conda activate java8
conda activate beast2 #has java installed
cat samples.txt | while read line ; do time /home/0_PROGRAMS/qualimap_v2.2.1/qualimap bamqc -bam merged/"$line"."$tagname".marked.bam -c -ip -nt 24 --java-mem-size=4G -outdir QC_reports/"$line"_qualimap ; done
for line in Uria_lomvia ; do time /home/0_PROGRAMS/qualimap_v2.2.1/qualimap bamqc -bam merged/"$line".RAZObowtie.marked.bam -c -ip -nt 24 --java-mem-size=8G -outdir QC_reports/"$line"_qualimap ; done #4G was not enough memory for Uria, which has the most data, so I had to increase the --java-mem-size parameter.

#conda activate fastqc
#multiqc QC_reports -n mapping_qc -o QC_reports -f

#get average depths of each sample
cat samples.txt | while read sample ; do echo "$sample" ; time /home/0_PROGRAMS/samtools-1.14/samtools depth merged/"$sample"."$tagname".marked.bam | awk '{sum+=$3; sumsq+=$3*$3} END { print "Average = ",sum/NR; print "Stdev = ",sqrt(sumsq/NR - (sum/NR)**2)}' ; done

```
qualimap:
* `-c`:Paint chromosome limits inside charts
* `-ip`: collect information on reads overlapping between paired end mates.
* `-nt`: number of threads to use
* `--java-mem-size=4G`: increases memory allowance, it was crashing after around half way done otherwise.

**Results**:  
* flagstats should show 100% of reads are mapped and properly paired (since that was our filter), and 50% are read 1 and 50% are read 2. It is not informative except to indicate if there was a problem with our filter. Everything looks good there  
* idxstats reports contig names, contig length, and number of mapped reads per contig. I would like to use this to identify the sex of the samples - see below.
* samtools stats gives you the info from flagstats and much more: insert size, avg quality, #bases mapped, and distributions for many attributes such as coverage, insert size, and quality. This is more useful. Looks fine. Most relevant results are tabulated below. All libraries show similar insert sizes so that's good.

This is the output of the average depth calculation:  
```
LTJA_MKP990
Average =  15.4599
Stdev =  30.6526

real	13m27.432s
user	18m57.248s
sys	0m22.672s

PAJA_B20730
Average =  14.834
Stdev =  39.2861

real	12m41.166s
user	17m43.868s
sys	0m22.852s

POJA_MKP1559
Average =  13.0102
Stdev =  48.5864

real	11m40.146s
user	16m15.584s
sys	0m22.560s

CHSK_MKP2451
Average =  9.55153
Stdev =  22.3274

real	11m56.073s
user	16m0.176s
sys	0m22.852s

GRSK_MKP1592
Average =  12.1698
Stdev =  30.6669

real	12m55.560s
user	17m38.712s
sys	0m23.592s

ANSK01
Average =  10.8256
Stdev =  20.6959

real	13m1.831s
user	17m10.452s
sys	0m23.940s

ANSK8
Average =  11.3689
Stdev =  20.1177

real	13m39.508s
user	17m56.704s
sys	0m23.472s

CISK2
Average =  12.5272
Stdev =  29.4882

real	13m22.662s
user	17m52.176s
sys	0m23.624s

CISK55
Average =  11.9856
Stdev =  21.3776

real	12m32.755s
user	16m55.032s
sys	0m23.076s

GRSK_MKP1593
Average =  8.97622
Stdev =  23.6284

real	11m15.002s
user	14m53.652s
sys	0m22.116s

POJA_4
Average =  11.9344
Stdev =  18.1122

real	13m59.662s
user	18m25.680s
sys	0m23.456s

POJA_IB2659
Average =  11.6249
Stdev =  21.3119

real	12m34.934s
user	16m57.308s
sys	0m23.888s

CISK3
Average =  9.25959
Stdev =  18.8653

real	12m8.593s
user	15m56.176s
sys	0m23.200s

Fratercula_arctica
Average =  8.40383
Stdev =  15.8753

real	12m34.344s
user	16m24.980s
sys	0m23.380s

Alca_torda
Average =  14.33
Stdev =  8.22002

real	13m44.283s
user	19m38.660s
sys	0m23.960s

PAJA_USNM606730
Average =  15.0834
Stdev =  7.16642

real	15m26.754s
user	21m4.400s
sys	0m24.564s

ANSK7
Average =  11.5732
Stdev =  16.0901

real	12m40.280s
user	17m11.932s
sys	0m22.488s

Uria_lomvia
Average =  48.8658
Stdev =  57.4272

real	18m7.121s
user	31m37.136s
sys	0m35.512s

```































# Appendix A: testing bowtie2 settings

This appendix lists the pipeline that I used to test different settings during a preliminary test run for the project (with just one sample and using *Alca torda* as the reference genome). If you are following this pipeline, you can skip this section, it is mostly for my records.  

## Testing settings
Here I am trying various bowtie2 settings with one sample. My reference genome is quite distant so I will probably need the most sensitive settings but I am curious to compare the results. I am tring with CISK, a sample that gave the nicest results from my kmer analysis.  
There are several different settings that can be customized, with info in the Bowtie2 [manual](http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml#bowtie2-options-mp).

Note the file structure is different than my final pipeline, but I am keeping it here as a record.
```bash
#Let's try with the sensitive setting of bowtie, mapping to Alca torda.
cd ~/Stercorariidae/raw_data/all/mappings/bowtie
line=CISK_3
time ~/tools/bowtie2-2.3.5-linux-x86_64/bowtie2 --sensitive --no-unal --threads 24 -q --phred33 --time -x ~/Stercorariidae/raw_data/Alca_torda_reference/VMED01_bowtie -1 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R1.fastq.gz -2 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R2.fastq.gz -S ./"$line"_razo_sensitive.sam 2> "$line"_razo_sensitive.log
time ~/tools/samtools-1.3/samtools view -S -b -@ 24 -h ./"$line"_razo_sensitive.sam > ./"$line"_razo_sensitive.bam
rm ./"$line"_razo_sensitive.sam

time ~/tools/bowtie2-2.3.5-linux-x86_64/bowtie2 --very-sensitive --no-unal --threads 24 -q --phred33 --time -x ~/Stercorariidae/raw_data/Alca_torda_reference/VMED01_bowtie -1 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R1.fastq.gz -2 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R2.fastq.gz -S ./"$line"_razo_vsensitive.sam 2> "$line"_razo_vsensitive.log
time ~/tools/samtools-1.3/samtools view -S -b -@ 24 -h ./"$line"_razo_vsensitive.sam > ./"$line"_razo_vsensitive.bam
rm ./"$line"_razo_vsensitive.sam

time ~/tools/bowtie2-2.3.5-linux-x86_64/bowtie2 --fast --no-unal --threads 24 -q --phred33 --time -x ~/Stercorariidae/raw_data/Alca_torda_reference/VMED01_bowtie -1 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R1.fastq.gz -2 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R2.fastq.gz -S ./"$line"_razo_fast.sam 2> "$line"_razo_fast.log
time ~/tools/samtools-1.3/samtools view -S -b -@ 24 -h ./"$line"_razo_fast.sam > ./"$line"_razo_fast.bam
rm ./"$line"_razo_fast.sam

time ~/tools/bowtie2-2.3.5-linux-x86_64/bowtie2 --very-fast --no-unal --threads 24 -q --phred33 --time -x ~/Stercorariidae/raw_data/Alca_torda_reference/VMED01_bowtie -1 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R1.fastq.gz -2 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R2.fastq.gz -S ./"$line"_razo_vfast.sam 2> "$line"_razo_vfast.log
time ~/tools/samtools-1.3/samtools view -S -b -@ 24 -h ./"$line"_razo_vfast.sam > ./"$line"_razo_vfast.bam
rm ./"$line"_razo_vfast.sam

time ~/tools/bowtie2-2.3.5-linux-x86_64/bowtie2 --very-fast-local --no-unal --threads 24 -q --phred33 --time -x ~/Stercorariidae/raw_data/Alca_torda_reference/VMED01_bowtie -1 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R1.fastq.gz -2 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R2.fastq.gz -S ./"$line"_razo_vfastloc.sam 2> "$line"_razo_vfastloc.log
time ~/tools/samtools-1.3/samtools view -S -b -@ 24 -h ./"$line"_razo_vfastloc.sam > ./"$line"_razo_vfastloc.bam
rm ./"$line"_razo_vfastloc.sam

time ~/tools/bowtie2-2.3.5-linux-x86_64/bowtie2 --very-sensitive-local --no-unal --threads 24 -q --phred33 --time -x ~/Stercorariidae/raw_data/Alca_torda_reference/VMED01_bowtie -1 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R1.fastq.gz -2 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R2.fastq.gz -S ./"$line"_razo_vsensitiveloc.sam 2> "$line"_razo_vsensitiveloc.log
time ~/tools/samtools-1.3/samtools view -S -b -@ 24 -h ./"$line"_razo_vsensitiveloc.sam > ./"$line"_razo_vsensitiveloc.bam
rm ./"$line"_razo_vsensitiveloc.sam

time ~/tools/bowtie2-2.3.5-linux-x86_64/bowtie2 --fast-local --no-unal --threads 24 -q --phred33 --time -x ~/Stercorariidae/raw_data/Alca_torda_reference/VMED01_bowtie -1 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R1.fastq.gz -2 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R2.fastq.gz -S ./"$line"_razo_fastloc.sam 2> "$line"_razo_fastloc.log
time ~/tools/samtools-1.3/samtools view -S -b -@ 24 -h ./"$line"_razo_fastloc.sam > ./"$line"_razo_fastloc.bam
rm ./"$line"_razo_fastloc.sam

time ~/tools/bowtie2-2.3.5-linux-x86_64/bowtie2 --sensitive-local --no-unal --threads 24 -q --phred33 --time -x ~/Stercorariidae/raw_data/Alca_torda_reference/VMED01_bowtie -1 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R1.fastq.gz -2 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R2.fastq.gz -S ./"$line"_razo_sensitiveloc.sam 2> "$line"_razo_sensitiveloc.log
time ~/tools/samtools-1.3/samtools view -S -b -@ 24 -h ./"$line"_razo_sensitiveloc.sam > ./"$line"_razo_sensitiveloc.bam
rm ./"$line"_razo_sensitiveloc.sam
```
* --sensitive: changes several settings that to a preset that would otherwise be controlled independantly. Includes --D 15 (allows 15 failed seed extensions before moving on to the next read), -R 2 (number of times a read with a repetitive seed will be re-seeded) -N 0 (no mismatches in seed allowed), -L 22 (length of the seed substring to align), -i S,1,1.15 (a function controlling the spacing between seed substrings to use during multiseed alignment)
* --no-unal: avoid reporting reads in the SAM file that failed to align
* --threads 28: number of threads to use
* -q: specifies that the files are fastq files
* --phred33: specifies that the files using phred33 quality encoding
* --time: record the time the command takes to run to standard error
* -x: the reference sequence index name (used previously with the command bowtie2-build)
* -1: the input read1 reads
* -2 the input read2 reads
* -U: the unpaired reads
* -S: the name of the output SAM file

Here are the timings:

setting|threads|realtime|user time|system time|
---|---|---|---|---|
very sensitive|24|154m21s|2836m40s|788m6s|
sensitive|24|157m38s|1936m44s|1707m59s|
fast|24|126m49s|1398m1s|1531m24s|
very fast|24|117m0s|1269m39s|1433m31s|
very fast local|24|153m26s|3286m56s|359m50s|
sensitive local|24|237m12s|5447m28s|222m38s|
very very sensitive|24|151m7s|3178m6s|407m38s|
very very very sensitive|24|151m16s|3115m7s|467m38s|

Clearly it is good to run on multiple cores or else each one will take 53 hours to run!
samtools view takes 6-7 min on 24 threads to convert the sam file to bam format. (51-64 min user time, 2 min system time)

From the above there is a slight time tradeoff going from very fast towards very sensitive, but really the time difference is small (117 minutes vs 154 minutes) so it should not be a consideration to getting the best results in this case. Instead we will look only at the mapping success rate.

Summarise the results with multiqc
```bash
conda activate fastqc
multiqc . -n CISK3_settings_comparisons
```
Thes ideal case would have as many reads as possible mapping to the genome, to one unique locus, with both pairs of the paired end reads mapping close together. Instead, we see that some reads do not map at all (red) and some reads map to more than one location (false positives) and some reads map discordantly (the read pairs map to different places, possibly due to structural rearrangements between the reference genome, more likely due to mapping errors.) In the end I am only going to keep the uniquely mapping, concordant paired end reads so I want to maximize that while minimizing the multimapped reads (false positives). Local alignment increases mapping rate at the cost of greater multimapping so I would prefer to sacrifice a little bit of real data to reduce false positive rate. 

I pick the `--very-sensitive` setting. It gave the best mapping results in my opinion. Different settings may be better for different situations but I like this one because the reference genome is quite distant and so I need the highest sensitivity.

We might be able to further improve results by customizing the settings rather than using the default settings. (This is shown in the above images as the "very very sensitive" setting. I am reducing the penalty for mismatches since I expect more mismatches in this distant reference genome. Here are my tests: 

```bash
cd ~/Stercorariidae/raw_data/all/mappings/bowtie
line=CISK_3
time ~/tools/bowtie2-2.3.5-linux-x86_64/bowtie2 --very-sensitive --no-unal --threads 24 -q --phred33 --time --mp 5,1 -x ~/Stercorariidae/raw_data/Alca_torda_reference/VMED01_bowtie -1 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R1.fastq.gz -2 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R2.fastq.gz -S ./"$line"_razo_vvsensitive.sam 2> "$line"_razo_vvsensitive.log
time ~/tools/samtools-1.3/samtools view -S -b -@ 24 -h ./"$line"_razo_vvsensitive.sam > ./"$line"_razo_vvsensitive.bam
rm ./"$line"_razo_vvsensitive.sam

time ~/tools/bowtie2-2.3.5-linux-x86_64/bowtie2 --very-sensitive --no-unal --threads 24 -q --phred33 --time --mp 5,1 -x ~/Stercorariidae/raw_data/Alca_torda_reference/VMED01_bowtie -1 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R1.fastq.gz -2 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R2.fastq.gz -S ./"$line"_Alctor_vvsensitive.sam 2> "$line"_Alctor_vvsensitive.log
time ~/tools/samtools-1.3/samtools view -S -b -@ 24 -h ./"$line"_Alctor_vvsensitive.sam > ./"$line"_Alctor_vvsensitive.bam
#rm ./"$line"_Alctor_vvsensitive.sam

#NOTE I am switching to a different release of the genome assembly now but it should be identical
time ~/tools/bowtie2-2.3.5-linux-x86_64/bowtie2 --very-sensitive --no-unal --threads 24 -q --phred33 --time --mp 5,1 -N 1 -x ~/Stercorariidae/raw_data/Alca_torda_reference/Alctor_bowtie -1 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R1.fastq.gz -2 ~/Stercorariidae/raw_data/"$line"/clean_data_trim/fltrd_adaptrlss"$line"_R2.fastq.gz -S ./"$line"_razo_vvvsensitive.sam 2> "$line"_razo_vvvsensitive.log
time ~/tools/samtools-1.3/samtools view -S -b -@ 24 -h ./"$line"_razo_vvvsensitive.sam > ./"$line"_razo_vvvsensitive.bam
rm ./"$line"_razo_vvvsensitive.sam

#Summarise the results with multiqc
conda activate fastqc
multiqc . -n CISK3_settings_comparisons
```
`--mp` sets the penalty for mismatches, between a min and max value depending on quality score. (default is 2-6)
`-N 1` allows 1 mismatch in the seed sequence. N cannot be set higher than 1 and is usually set to 0 because it makes it much slower.

The "very very very" sensitive setting with `-N 1` was actually worse than the "very very" sensitive setting which did not allow mismatches in the seed sequence. I will scrap that one.

With the "very very sensitive" setting we have 71.34% of pairs mapping once concordantly (4.4% multimapped), the best rate so far. I will use this setting!

# Appendix B: testing BWA
I would also like to try using bwa and compare to bowtie2. As aboe, I will run CISK first to compare.
```bash
mkdir /home/0_GENOMES1/0_RESEQUENCING_PROJECTS/2_PROJECTS/Stercorariidae/1_ALIGNMENT_Alctor_0a_1b
cd /home/0_GENOMES1/0_RESEQUENCING_PROJECTS/2_PROJECTS/Stercorariidae/1_ALIGNMENT_Alctor_0a_1b
mkdir mapping_logs

#index the reference genome
/home/0_PROGRAMS/bwa/bwa index /home/0_GENOMES1/0_PUBLISHED_GENOMES/Alca_torda/GCA_008658365.1_bAlcTor1_primary_genomic.fna

#run bwa in serial or in parallel
sample=CISK_3 #in serial

time /home/0_PROGRAMS/bwa/bwa mem -t 24 /home/0_GENOMES1/0_PUBLISHED_GENOMES/Alca_torda/GCA_008658365.1_bAlcTor1_primary_genomic.fna /home/0_GENOMES1/0_RESEQUENCING_PROJECTS/1_PROCESSED_READS/3_TRIMMED/Stercorariidae/fltrd_adaptrlss"$sample"_R1.fastq.gz /home/0_GENOMES1/0_RESEQUENCING_PROJECTS/1_PROCESSED_READS/3_TRIMMED/Stercorariidae/fltrd_adaptrlss"$sample"_R2.fastq.gz 2> mapping_logs/"$sample"_Alctor_bwa.log | time /home/0_PROGRAMS/samtools-1.9/samtools view -S -b -@ 24 -h > "$sample"_Alctor_bwa.bam 

#in parallel
cat samples.txt | parallel time '/home/0_PROGRAMS/bwa/bwa mem -t 4 /home/0_GENOMES1/0_PUBLISHED_GENOMES/Alca_torda/GCA_008658365.1_bAlcTor1_primary_genomic.fna /home/0_GENOMES1/0_RESEQUENCING_PROJECTS/1_PROCESSED_READS/3_TRIMMED/Stercorariidae/fltrd_adaptrlss{1}_R1.fastq.gz /home/0_GENOMES1/0_RESEQUENCING_PROJECTS/1_PROCESSED_READS/3_TRIMMED/Stercorariidae/fltrd_adaptrlss{1}_R2.fastq.gz 2> mapping_logs/{1}_Alctor_bwa.log | time /home/0_PROGRAMS/samtools-1.9/samtools view -S -b -@ 4 -h > {1}_Alctor_bwa.bam'

#check results
time /home/0_PROGRAMS/bamtools/bin/bamtools stats -in "$sample"_Alctor_bwa.bam > "$sample"_Alctor_bwa.bamstats.txt
cat samples.txt | parallel time '/home/0_PROGRAMS/bamtools/bin/bamtools stats -in {1}_Alctor_bwa.bam > {1}_Alctor_bwa.bamstats.txt'

```
* -S: the input is a SAM file (no longer required as this can be automatically detected)
* -b: the output will be BAM format
* -@: number of threads to use for BAM compression
* -h: include the header in the output

**timing**: running CISK on it's own on 24 threads took 103m56 (2431m29). Running 7 at a time, the last finished at 654m24 (2566m37).

Now we will sort and filter and index this bam file using samtools. We are filtering so that we take out the ambiguously mapped reads and any reads where the two mates map to different places (this could be correct or could be errors). We need to sort it because the raw bam file is all out of order and it will be much easier to analyze downstream if the sequences are in order.  

```bash
cd /home/0_GENOMES1/0_RESEQUENCING_PROJECTS/2_PROJECTS/Stercorariidae/1_ALIGNMENT_Alctor_0a_1b
#Keep only the alignments which are higher confidence and preserve the read pairs properly, then sort this by position
cat samples.txt | while read sample ; do time /home/0_PROGRAMS/samtools-1.9/samtools view -@ 24 -h -b -q 5 -f2 -F4 "$sample"_Alctor_bwa.bam | /home/0_PROGRAMS/samtools-1.9/samtools sort --threads=24 -o "$sample"_Alctor_bwa_unique_sorted.bam ; done

#index the sorted bam file
cat samples.txt | while read sample ; do time /home/0_PROGRAMS/samtools-1.9/samtools index "$sample"_Alctor_bwa_unique_sorted.bam ; done
#done
```
* `-@`: number of threads to use for BAM compression
* `-h`: include the header in the output
* `-q 5`: Skip alignments with MAPQ smaller than the specified number. This is to avoid multimapped sequences and mappings with low confidence. You could filter by 0 or 1, or 5 or 10, there is a discussion [here](https://www.biostars.org/p/101533/).
* `-f2`: only include properly paired reads
* `-F4`: exclude unmapped reads
* `-b`: the output will be BAM format
* `-o`: output file of samtools sort
**Timing**: sorting/filtering took 8-16 mins per sample (24 threads each). I did not do them in parallel because I found that it took hours last time I did that, running one at a time seems much faster (usually parallel is faster)! Indexing also took 2m49-4m24 per sample.

**Results**: BWA had a much higher mapping rate to the distant reference genome compared to bowtie. Now, some of these additional mappings may of course be false positives. The difference is less striking for the outgroup which is fairly close to the reference. In the end I did run some preliminary downstream analyses ti compare the bwa and bowtie2 results, and the results were qualitatively the same.

## Quality Control of bwa mappings
We should examine the results of bamtools stats (above). These can be visualized by multiQC, except there is a glitch (at least in my version of multiQC/bamtools) where the first line of the bamstats files comes out as a blank line, and so they are not recognized by multiQC. Here is a code to remove this blank line so MultiQC can read them:
```bash
#remove the first line if it is blank
cat samples.txt | while read sample ; do sed -i '1{/^$/d}' "$sample"_Alctor_bwa.bamstats.txt ; done  #removes first line if it is blank

conda activate fastqc
multiqc . -n bwa_mapping_stats
```
Here are the results of all my mappings:

| Mapping Settings                | %Mapped |
|---------------------------------|---------|
| ANSK7_Alctor_bwa                | 97.60%  |
| ANSK7_Alctor_vvsensitive        | 88.40%  |
| CHSK_MKP2451_Alctor_bwa         | 97.30%  |
| CHSK_MKP2451_Alctor_vvsensitive | 82.10%  |
| CISK_3_Alctor_bwa               | 98.20%  |
| CISK_3_Alctor_vvsensitive       | 82.50%  |
| CISK_3_razo_fast                | 64.40%  |
| CISK_3_razo_sensitive           | 74.40%  |
| CISK_3_razo_sensitiveloc        | 92.70%  |
| CISK_3_razo_vfast               | 64.10%  |
| CISK_3_razo_vfastloc            | 74.30%  |
| CISK_3_razo_vsensitive          | 79.00%  |
| GRSK_MKP1592_Alctor_bwa         | 97.20%  |
| GRSK_MKP1592_Alctor_vvsensitive | 80.70%  |
| LTJA_MKP990_Alctor_bwa          | 97.70%  |
| LTJA_MKP990_Alctor_vvsensitive  | 83.10%  |
| PAJA_B20730_Alctor_bwa          | 96.90%  |
| PAJA_B20730_Alctor_vvsensitive  | 80.60%  |
| POJA_MKP1559_Alctor_bwa         | 96.20%  |
| POJA_MKP1559_Alctor_vvsensitive | 79.40%  |
| Urilom_Alctor_bwa               | 98.10%  |
| Urilom_Alctor_vvsensitive       | 95.00%  |

As you can see the bwa (Alctor_bwa) mappings had a much higher rate than the corresponding bowtie2 mappings (Alctor_vvsensitive). It is a 14.9% difference on average for the skuas, but only a 3.1% difference for the auk which is very close to the reference. Strangely, CISK had even higher mapping rate than the Urilom with bwa! This at first glance seems much better than bowtie2, however, I examined the coverage and heterozygosity across the Z in the female samples and found that bwa gave much higher Z heterozygosity than bowtie. This is a concern since it implies that there are more mismapped reads - the Z should not be heterozygous in females outside of the pseudoautosomal region!. This is likely fixable by tweaking the settings, but I will stick to bowtie2 for this project.

### Quality control of bwa mappings

```bash
cd /home/0_GENOMES1/0_RESEQUENCING_PROJECTS/2_PROJECTS/Stercorariidae/1_ALIGNMENT_Alctor_0a_1b

mkdir bam_stats
cat samples.txt | parallel 'time /home/0_PROGRAMS/samtools-1.9/samtools flagstat {1}_Alctor_bwa_unique_sorted.bam > bam_stats/flagstats_{1}.txt'
cat samples.txt | parallel 'time /home/0_PROGRAMS/samtools-1.9/samtools idxstats {1}_Alctor_bwa_unique_sorted.bam > bam_stats/idxstats_{1}.txt'
cat samples.txt | parallel 'time /home/0_PROGRAMS/samtools-1.9/samtools stats {1}_Alctor_bwa_unique_sorted.bam > bam_stats/samstats_{1}.txt'

cat samples.txt | while read sample ; do time /home/0_PROGRAMS/qualimap_v2.2.1/qualimap bamqc -bam ./"$sample"_Alctor_bwa_unique_sorted.bam -c -ip -nt 24 --java-mem-size=4G -outdir "$sample"_qualimap ; done

conda activate fastqc
multiqc ./bam_stats -n mapping_qc
```
**Results**:  
* flagstats should show 100% of reads are mapped and properly paired (since that was our filter), and 50% are read 1 and 50% are read 2.  
* Everything looks good there  
* samtools stats gives you the info from flagstats and much more: insert size, avg quality, #bases mapped, and distributions for many attributes such as coverage, insert size, and quality.
* Looks fine. Most relevant results are tabulated below. All libraries show similar insert sizes so that's good.
* idxstats reports contig names, contig length, and number of mapped reads per contig. I would like to use this to identify the sex of the samples.

Now, let's check the Z:Autosome ratio:

Contig `CM018101.1` is the Z chromosome, and it can be compared to chromosome CM018079.1, the autosome of the closest size.

| Sample | Z/autosome  | million reads mapped |
|--------|-------------|----------------------|
| LTJA   | 0.560696507 | 158.3                |
| PAJA   | 0.582642932 | 152.8                |
| POJA   | 0.934556116 | 129.7                |
| GRSK   | 0.562979718 | 128.8                |
| ANSK   | 0.975760759 | 129                  |
| CISK   | 0.572572584 | 161.1                |
| CHSK   | 0.562407351 | 100.3                |
| Urilom | 0.562690047 | 236                  |

I am not very happy with this. While the Z/autosome ratio ranged from 0.492-0.506 in Bowtie2 vvsensitive settings (closely around the expected 0.500 ratio), now it is 0.561-0.583. I feel that this extra 6-8% is most likely due to autosomal sequences being erroneously mapped to incorrect chromosomes, and thus reducing the magnitude of the difference between autosome and Z chromosome. I would expect wrong mappings to raise the Z/autosome ratio (at the worst extreme, if all reads were being randomly assigned, I would expect a ratio of 1.0). So, I estimate that there is at least around 7/57 = 12.3% error rate! (that is purposely an underestimate, it assumes that all the autosome reads are correctly mapped, and so only measures the excess above that expected amount on Z) (it also ignores possibility for differences in sequencing depth and mapability of different chromosomes, or for a greater number of collapsed repeats on chrZ). Well, that gets rid of the benefit of the extra mapping rate! (Note: later I realized some W chromosome reads are being mapped to the Z, and bwa is likely mapping more W reads to the Z than the bowtie settings were, so this may be a large explanation of the difference)

In conclusion, I think that I am best to still with Bowtie2 for this one. Better to have less data that is good than to have less-good data!

Important: this does **not** mean that bwa itself is worse (I think it is a great program), but with my dataset and the specific settings that I used, the Bowtie2 vvsensitive settings seem to be a better choice.
